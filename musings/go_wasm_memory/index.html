<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>Go/Wasm &lt;-> JS Memory | Odin</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="This post will be about how I accessed the Go/Wasm memory buffer from the Javascript side. I wanted to get this one out, because it took me a very long time to work through it, and I had to piece together a ton of random internet resources. All the code is pulled from the site, but I&rsquo;ve simplified it the best I can.
Go/Wasm instantiation in JS When instantiating the Go/Wasm &ldquo;application&rdquo; in JS-land, its important to keep a reference to the WebAssembly object used in that process."><meta name=generator content="Hugo 0.112.1"><meta name=ROBOTS content="INDEX, FOLLOW"><link rel=stylesheet href=https://www.odinseye.cloud/ananke/css/main.min.5634740bea2b6888928cdc68ce34cea639f0daf949dc791c38696b64f8558ca0.css><link rel="shortcut icon" href=https://www.odinseye.cloud/img/godin_icon.png type=image/x-icon><meta property="og:title" content="Go/Wasm <-> JS Memory"><meta property="og:description" content="This post will be about how I accessed the Go/Wasm memory buffer from the Javascript side. I wanted to get this one out, because it took me a very long time to work through it, and I had to piece together a ton of random internet resources. All the code is pulled from the site, but I&rsquo;ve simplified it the best I can.
Go/Wasm instantiation in JS When instantiating the Go/Wasm &ldquo;application&rdquo; in JS-land, its important to keep a reference to the WebAssembly object used in that process."><meta property="og:type" content="article"><meta property="og:url" content="https://www.odinseye.cloud/musings/go_wasm_memory/"><meta property="article:section" content="musings"><meta property="article:published_time" content="2021-11-02T20:56:45-07:00"><meta property="article:modified_time" content="2021-11-02T20:56:45-07:00"><meta itemprop=name content="Go/Wasm <-> JS Memory"><meta itemprop=description content="This post will be about how I accessed the Go/Wasm memory buffer from the Javascript side. I wanted to get this one out, because it took me a very long time to work through it, and I had to piece together a ton of random internet resources. All the code is pulled from the site, but I&rsquo;ve simplified it the best I can.
Go/Wasm instantiation in JS When instantiating the Go/Wasm &ldquo;application&rdquo; in JS-land, its important to keep a reference to the WebAssembly object used in that process."><meta itemprop=datePublished content="2021-11-02T20:56:45-07:00"><meta itemprop=dateModified content="2021-11-02T20:56:45-07:00"><meta itemprop=wordCount content="742"><meta itemprop=keywords content="30 Minute Post,"><meta name=twitter:card content="summary"><meta name=twitter:title content="Go/Wasm <-> JS Memory"><meta name=twitter:description content="This post will be about how I accessed the Go/Wasm memory buffer from the Javascript side. I wanted to get this one out, because it took me a very long time to work through it, and I had to piece together a ton of random internet resources. All the code is pulled from the site, but I&rsquo;ve simplified it the best I can.
Go/Wasm instantiation in JS When instantiating the Go/Wasm &ldquo;application&rdquo; in JS-land, its important to keep a reference to the WebAssembly object used in that process."><script async src="https://www.googletagmanager.com/gtag/js?id=G-KWNZJ4607L"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-KWNZJ4607L",{anonymize_ip:!1})}</script></head><body class="ma0 avenir bg-near-white production"><header><div class=bg-black><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=https://www.odinseye.cloud/ class="f3 fw2 hover-white no-underline white-90 dib"><img src=https://www.odinseye.cloud/img/godin_icon.png class="w100 mw5-ns" alt=Odin></a><div class="flex-l items-center"><ul class="pl0 mr3"><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=https://www.odinseye.cloud/about/ title="About page">About</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=https://www.odinseye.cloud/announcements/ title="Announcements page">Announcements</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=https://www.odinseye.cloud/hurricane/ title="Hurricanes page">Hurricanes</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=https://www.odinseye.cloud/maps/ title="Map page">Map</a></li><li class="list f5 f4-ns fw4 dib pr3"><a class="hover-white no-underline white-90" href=https://www.odinseye.cloud/musings/ title="Musings page">Musings</a></li></ul></div></div></nav></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw9 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">MUSINGS</aside><h1 class="f1 athelas mt3 mb1">Go/Wasm &lt;-> JS Memory</h1><p><time class="f6 mv4 dib tracked" datetime=2021-11-02T20:56:45-07:00>November 2, 2021</time></header><div class="nested-copy-line-height lh-copy serif f4 nested-links nested-img mid-gray pr4-l w-two-thirds-l"><p>This post will be about how I accessed the Go/Wasm memory buffer from the Javascript side. I wanted to get this one out, because it took me a very long time to work through it, and I had to piece together a ton of random internet resources. All the code is pulled from the site, but I&rsquo;ve simplified it the best I can.</p><h1 id=gowasm-instantiation-in-js>Go/Wasm instantiation in JS</h1><p>When instantiating the Go/Wasm &ldquo;application&rdquo; in JS-land, its important to keep a reference to the WebAssembly object used in that process. It gets used to access the memory buffer later</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-html data-lang=html><span style=display:flex><span>&lt;<span style=color:#f92672>script</span>&gt;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> <span style=color:#a6e22e>wasmRef</span>;  <span style=color:#75715e>// Need to keep track of this
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>go</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Go</span>();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>async</span> <span style=color:#66d9ef>function</span> <span style=color:#a6e22e>init</span>() {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>wasmRef</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>WebAssembly</span>.<span style=color:#a6e22e>instantiateStreaming</span>(<span style=color:#a6e22e>fetch</span>(<span style=color:#e6db74>&#34;/wasm/lib.wasm&#34;</span>), <span style=color:#a6e22e>go</span>.<span style=color:#a6e22e>importObject</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>go</span>.<span style=color:#a6e22e>run</span>(<span style=color:#a6e22e>wasmRef</span>.<span style=color:#a6e22e>instance</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>init</span>();
</span></span><span style=display:flex><span>&lt;/<span style=color:#f92672>script</span>&gt;
</span></span></code></pre></div><h1 id=gowasm-store-data-into-buffer-return-pointer>Go/Wasm store data into buffer, return pointer</h1><p>Well, explicitly storing data into the buffer isn&rsquo;t required, since the buffer is the entire memory space available to the Go/Wasm code. But, it needs to be encoded into a format that can be read on the JS side. In this case, I encode the GeoJSON Object into a byte slice (though I&rsquo;m going to use a simpler string below).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#f92672>package</span> <span style=color:#a6e22e>main</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> (
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;encoding/json&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;reflect&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;syscall/js&#34;</span>
</span></span><span style=display:flex><span>	<span style=color:#e6db74>&#34;unsafe&#34;</span>
</span></span><span style=display:flex><span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Pin buffer to global, so it doesn&#39;t get GC&#39;d
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>var</span> <span style=color:#a6e22e>wasmMemoryBuffer</span> []<span style=color:#66d9ef>byte</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>GetString</span>(<span style=color:#a6e22e>this</span> <span style=color:#a6e22e>js</span>.<span style=color:#a6e22e>Value</span>, <span style=color:#a6e22e>i</span> []<span style=color:#a6e22e>js</span>.<span style=color:#a6e22e>Value</span>) <span style=color:#66d9ef>interface</span>{} {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>emptyGeoJSON</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}{
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;type&#34;</span>: <span style=color:#e6db74>&#34;FeatureCollection&#34;</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;features&#34;</span>: make([]<span style=color:#66d9ef>interface</span>{}, <span style=color:#ae81ff>0</span>),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>wasmMemoryBuffer</span>, <span style=color:#a6e22e>_</span> = <span style=color:#a6e22e>json</span>.<span style=color:#a6e22e>Marshal</span>(<span style=color:#a6e22e>emptyGeoJSON</span>)
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>buffHeader</span> <span style=color:#f92672>:=</span> (<span style=color:#f92672>*</span><span style=color:#a6e22e>reflect</span>.<span style=color:#a6e22e>SliceHeader</span>)(<span style=color:#a6e22e>unsafe</span>.<span style=color:#a6e22e>Pointer</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>wasmMemoryBuffer</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>retMap</span> <span style=color:#f92672>:=</span> <span style=color:#66d9ef>map</span>[<span style=color:#66d9ef>string</span>]<span style=color:#66d9ef>interface</span>{}{
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;ptr&#34;</span>: <span style=color:#a6e22e>buffHeader</span>.<span style=color:#a6e22e>Data</span>,
</span></span><span style=display:flex><span>		<span style=color:#e6db74>&#34;len&#34;</span>:  len(<span style=color:#a6e22e>wasmMemoryBuffer</span>),
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#a6e22e>retMap</span>
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>registerCallbacks</span>() {
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>js</span>.<span style=color:#a6e22e>Global</span>().<span style=color:#a6e22e>Set</span>(<span style=color:#e6db74>&#34;GetString&#34;</span>, <span style=color:#a6e22e>js</span>.<span style=color:#a6e22e>FuncOf</span>(<span style=color:#a6e22e>GetString</span>))
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>main</span>(){
</span></span><span style=display:flex><span>	<span style=color:#a6e22e>c</span> <span style=color:#f92672>:=</span> make(<span style=color:#66d9ef>chan</span> <span style=color:#66d9ef>struct</span>{}, <span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>// register functions
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#a6e22e>registerCallbacks</span>()
</span></span><span style=display:flex><span>	<span style=color:#f92672>&lt;-</span><span style=color:#a6e22e>c</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The major steps here are:</p><ol><li>Keep the reference to the <code>wasmMemoryBuffer</code> byte slice global, so it doesn&rsquo;t get garbage collected unexpectedly. This will require explicit functions to clear out <code>wasmMemoryBuffer</code> if you want to deallocate it (which is just a function that sets it to an empty slice)</li><li>The simple GeoJSON object is turned into a byte slice using the standard <code>json.Marshal</code> function</li><li>This is the odd bit of pointer magic, and it requires knowing what the <code>slice</code> type is under the hood (<a href=https://faun.pub/slices-in-golang-introduction-4b11ac451049>first reasonable link</a> I found). The upshot is this line, <code>buffHeader := (*reflect.SliceHeader)(unsafe.Pointer(&amp;wasmMemoryBuffer))</code>, gets you the slice header for <code>wasmMemoryBuffer</code>, and the pointer to the backing array is accessible at <code>buffHeader.Data</code></li><li><code>retMap</code> is just a basic map to cleanly package up both the pointer to our data and the length of our data, we&rsquo;ll need both on the JS side.</li></ol><h1 id=read-from-buffer-on-js-side>Read from buffer on JS side</h1><p>On the JS side, we get the pointer information, and use them to pull the data out of the correct section of WebAssembly memory.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>ptrMap</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>GetString</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>wasmBuffer</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>wasmRef</span>.<span style=color:#a6e22e>instance</span>.<span style=color:#a6e22e>exports</span>.<span style=color:#a6e22e>mem</span>.<span style=color:#a6e22e>buffer</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>dataSection</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>wasmBuffer</span>.<span style=color:#a6e22e>slice</span>(<span style=color:#a6e22e>ptrMap</span>.<span style=color:#a6e22e>ptr</span>, <span style=color:#a6e22e>ptrMap</span>.<span style=color:#a6e22e>ptr</span> <span style=color:#f92672>+</span> <span style=color:#a6e22e>ptrMap</span>.<span style=color:#a6e22e>len</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>decodedGeoJSON</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TextDecoder</span>(<span style=color:#e6db74>&#34;utf-8&#34;</span>).<span style=color:#a6e22e>decode</span>(<span style=color:#a6e22e>wasmBuffer</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>let</span> <span style=color:#a6e22e>GeoJSONObjects</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>decodedGeoJSON</span>)
</span></span></code></pre></div><p>Here, we:</p><ol><li>Call the Go/Wasm function to get the pointer and data length</li><li>Get a reference to the Wasm memory area (some online posts have this as <code>wasmRef.instance.exports.memory.buffer</code>, note memory vs mem, I&rsquo;m not sure if the API changed or something)</li><li>use the pointer and data length to get the correct section of bytes out of the memory. The datatype here is an Array of Uint8 values.</li><li>Finally, use a TextDecode class to decode the Uint8 values, and run that through JSON.parse() to get the objects out.</li></ol><h1 id=wrap-up>Wrap Up</h1><p>That&rsquo;s the key parts! I didn&rsquo;t address getting the Go code compiled to Wasm, the general structure of the code, nor any of the mapping stuff. I think the biggest thing I was tripped up on was the amount old information floating around in web resources, many were several years old which definitely mattered. The other big gotcha was that, initially, I was returning the pointer to the slice <code>wasmMemoryBuffer</code> <em>itself</em> (<code>&amp;wasmMemoryBuffer</code>), rather than the pointer to the slice <em>backing array</em> (<code>buffHeader.Data</code>), which was very confusing as you end up in an inscrutable memory area if you do that.</p><p>I&rsquo;m not sure, at the data size I&rsquo;m doing now, that this technique matters too much over just returning the string and eating the copy going from Go/Wasm to JS (if there&rsquo;s a copy? I don&rsquo;t know that for sure, information is hard to find). But, this method has some neat synergies with using ProtoBuff instead of a string to encode the data, since ProtoBuff is a binary format it can encode objects directly to and from the memory space, without needing an intermediary string decode or json parse.</p><ul class=pa0><li class=list><a href=https://www.odinseye.cloud/tags/30-minute-post class="link f5 grow no-underline br-pill ba ph3 pv2 mb2 dib black sans-serif">30 Minute Post</a></li></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"><div class="bg-light-gray pa3 nested-list-reset nested-copy-line-height nested-links"><p class="f5 b mb3">Related</p><ul class="pa0 list"><li class=mb2><a href=https://www.odinseye.cloud/musings/map/>Maps!</a></li></ul></div></aside><div class=_fa7cdd4c68507744 data-zone=204c5806c2404851a377eda9d8eedf91 style="width:240px;height:400px;display:inline-block;margin:0 auto"></div></article></main><footer class="bg-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://www.odinseye.cloud>&copy; Odin 2023</a><div></div></div></footer></body></html>